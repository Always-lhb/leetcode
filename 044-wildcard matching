/*
题目大意：通配符匹配，'?'代表单个字符，'*'代表任意字符串，包括空串
解题思路：
  1.直接想到第10题匹配问题，希望用类似的回溯法递归解决，然而超时了... 递归代码如下
  2.看来动归逃不过了...
*/

/*超时的递归...*/
class Solution {
public:
    bool isMatch(string s, string p) {
        if(p.empty()) return s.empty();
        if(s.empty()) return p.empty() || p[0]=='*' && isMatch(s, p.substr(1));
        if(p[0] == '*') return isMatch(s, p.substr(1)) || !s.empty()&&isMatch(s.substr(1), p);
        if(p[0] == '?') return !s.empty() && isMatch(s.substr(1), p.substr(1));
        else{
            if(s[0] == p[0])
                return isMatch(s.substr(1), p.substr(1));
            else
                return false;
        }
    }
};


/*
看了DISCUSS之后，惊奇地发现最受欢迎的解法与我的类似，都是对当前s[i],p[j]进行判断并后移
tips:
  1. (p[j] == s[i] || p[j] == '?'): s,p均后移
  2. (p[j] == '*')：对于连续*号，记录最后一个的位置，并记录此时对应s的位置
  3. (star_id != -1): p里出现过*号，且当前位置s与p不匹配，则不断将已匹配之后的s后移
  4. 均不满足上述条件时，说明不匹配
  5. 判断p的最后一个*号后，是否仍有其他字符
*/

/*AC代码*/
class Solution {
public:
    bool isMatch(string s, string p) {
        int i = 0, j = 0;
        int star_id = -1, s_id = 0;
        
        while(i < s.size()){
            if(j < p.size() && (p[j] == s[i] || p[j] == '?')){
                i++;
                j++;
                continue;
            }
            if(j < p.size() && p[j] == '*'){ //star_id：最后一个*的下标，s_id：此时字符串s的下标。此时表示*匹配空串
                star_id = j;
                s_id = i;
                j++;
                continue;
            }
            if(star_id != -1){ //通过最后一个*不断地匹配s的下一个字符
                j = star_id + 1;
                if(j == p.size()) return true; //最后一个*是p的最后一个字符，则它可以匹配s剩余所有的字符
                s_id = s_id + 1;
                i = s_id;
            }
            else{
                return false;
            }
        }
        while(p[j] == '*')
            j++;
        return !p[j];
    }
};
