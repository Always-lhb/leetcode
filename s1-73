1.TwoSum 返回i,j，使得nums[i]+nums[j]=target，唯一
  对于N-Sum问题，固定一个数，查找另一个数；并利用unordered_map<int, int>使复杂度为O(n)
2.Add Two Numbers 以链表形式实现两数相加
  使用带头结点的结果链表。注意要先求进位再求当前位的值，不然flag恒等于0
3.Longest-substring-without-repeating-characters 返回字符串的无重复字符的最长子串
  遍历找到每个字符起始的最长符合要求子串即可
4.Median-of-two-sorted-arrays 求两个有序数组合并后的中位数
  查找两个有序数列A,B合并后的中位数，转化为查找A,B合并后的第k小数（k根据奇偶而定）
  递归：分别查找A,B的第pa，pb(pb=k-pa)小数
  if(A[pa-1] < B[pb-1]): A[0..pa-1]均属于合并后的前k小数，舍弃
  if(A[pa-1] > B[pb-1]): B[0..pb-1]均属于合并后的前k小数，舍弃
  if(A[pa-1] == B[pb-1]): 命中，返回
  临界条件：假设总有A.size()<=B.size()
  if(A.size() == 0) return B[k-1];
  if(k == 1) return min(A[0], B[0]);
  
  tips:奇偶判断 
  if(a & 0x1) 奇数
  else  偶数
5.Longest-palindromic-substring 求最长回文子串
  Manacher算法
  对字符串预处理，统一奇偶：abba -> #a#b#b#a#
  声明辅助数组p，存放以每个字符为中心的最长回文串半径
  
  当得到回文串中心id,回文串半径max_len之后，对应于原字符串，
  回文子串起始位置为(id-max_len+1)/2，回文子串总长度为max_len-1.
6.Zigzag-conversion 将字符串转换成Z字形
  定义nrows个string，分别存储转换后的每行，再按行号连接string即可
  根据字符下标和方向，找到应存入的string
7.Reverse Integer 整形反转
  public:
    int reverse(int x) {
        long res = 0;
        while(x != 0){
            res = res * 10 + x % 10;
            x /= 10;
        }
        return (res > INT_MAX || res < INT_MIN) ? 0 : res;
    }
  };
8.String to Integer 
  将string转换为integer
  1.忽略string开始的所有空格
  2.正负号可选
  3.正负号后跟尽可能多的数字
  4.数字后面的其他字符忽略即可
  5.integer越界返回INT_MAX或INT_MIN

  ps:
  1.为防止溢出，声明为long
  2.得到res后，直接进行溢出判断
9.Palindrome-number 给定一个int，判定是否为回文数
  对最高位和最低位进行判断，如果相同，去掉这两位继续判断，否则返回false;负数不是回文数
10.Regular-expression-matching 正则匹配，其中'.'代表任何字符，'*'表示前一位字符重复任意次
  f[i][j]: s[0..i-1]与p[0..j-1]是否匹配，问题变成了求解f[s.size()][p.size()]
  f[i][j]:
      if(p[j-1] == '*'): 
          此时p[j-2]+p[j-1]可能表示empty，即去掉p的后两位: f[i][j-2]
          或者p[j-2]+p[j-1]表示>=1个s[i-1]，即去掉s的末位: (s[i-1]==p[j-2]||p[j-2]=='.')&&(f[i-1][j])
      if(p[j-1] != '*'):
          s和p的末位比较且去掉s和p的末位：f[i][j] = (s[i-1] == p[i-1] || p[i-1] == '.') && f[i-1][j-1]
  初始化：
      1.f[0][0] = true;
      2.当p空时，对于s的第i个字符有f[i][0]=false
      3.当s空时，对于p的第j个字符，判断 j > 1 && p[j-1] == '*' && f[0][j-2]
11.Container-with-most-water 给定数组 height,其中height[i]表示坐标轴上的一个点(i, height[i])，对每个点做垂直于x轴的线段，求出两条线段与x轴所代表容器能盛放的最大水量
  首先通过第一个和最后一个点求出widest container，其他container必须比这个container更高才有可能超过它的容量
12.Integer to Roman 将integer类型转换为Roman字符串,假设此ineger大小在0-3999之间
  I:1
  V:5
  X:10
  L:50
  C:100
  D:500
  M:1000
  分别定义4个string数组，对应千百十个位，再将字符串连接即可
13.Roman to Integer
  将罗马数字对应的integer存入map，从个到千判断，若um[s[i]]<um[s[i+1]]，sum-=um[s[i]];否则sum+=um[s[i]]
14.longest-common-prefix 对于vector<string> strs，返回最长共同前缀
  对每一位，遍历整个string数组，如果均相同则加入，否则退出循环
15.3Sum 对给定vector<int>，返回所有的a,b,c，使得a+b+c=0;注意去重
  排序，对给定nums[i],利用卡尺法查找nums[left]+nums[right] = -nums[i]
16.3Sum Closest 对给定vector<int> nums和target，返回nums中的a,b,c，使得a+b+c最接近target；假设只有一组，不需去重。
  排序+卡尺法
17.letter-combinations-of-a-phonenumber 对于输入的数字，按照手机键位，返回所有可能的字符串和
  dfs
18.4Sum
  N-Sum问题：排序+卡尺法
19.remove-nth-node-from-end-of-list 删除链表的倒数第n个节点
  计算出倒数第n个节点是正数第几个，然后求解。注意当去掉的节点是首节点时的特殊判断。
20.valid parentheses 对于由(),[],{}构成的字符串，判断是否符合规范
  栈stack的简单应用
21.merge-two-sorted-list 合并两有序链表
  对两个链表，从起始位置开始判断。链表问题都统一使用带头结点的链表即可。
22.create-parentheses 根据输入的个数n，构造所有符合规则的具有n个'('和n个')'的字符串
  dfs
  left,right分别代表剩余左右括号数目，合法情况下left<=right。
  当left=right=0时：得到一个解，返回；
  当left<right时：如果left>0，插入一个左括号递归，如果right>0，插入一个右括号递归
  当left=right时：只能插入左括号并递归
23.merger-k-sorted-lists 合并k个有序链表
  k路归并->堆priority_queue<>
24.swap-nodes-in-pairs 给定一个链表，交换两个相邻节点的值，返回头指针。如：给定1->2->3->4，要求返回2->1->4->3。要求只能用常数空间。
  每次交换前判断链表是否还有两个节点，如果有就交换这两个节点。需要标注尾节点，将链表连接起来
25.reverse nodes in k-group 给定链表和数字k，以k个节点为一组进行反转
  首先写出链表反转的reverse()函数，然后对原链表作处理，每k个节点翻转一次。
  res:带头结点的结果
  pre:当前段的前一个节点，即上一段的最后一个节点。每k个节点为一段
  head:当前段首节点
  tail:当前段尾节点
26.remove-duplicates from sorted array 对升序数组，去除数组中重复的项，并返回剩余数组长度。确保数组的前len个元素是不重复的，之后的元素无所谓
  用两个指针分别指向当前位置，与当前有效位置。通过i遍历数组，j代表不重复元素的实际位置。
27.remove-element 与上一题基本相同，返回数组中值不为val的元素个数len，只需要保证前len个元素正确即可
  同样，用两个指针分别指向当前位置，与当前有效位置
28.implement strStr 给定两个字符串haystack,needle，返回needle在haystack里的其实下标，如果没有则返回1
  从起始位置开始，对每个合法位置进行遍历。
  kmp算法
29.devide-two-integers 不允许使用/,*,%,计算出两数相除的结果
  位运算，即左移<<和右移>>。左移代表乘2，右移代表除2
  tips:
    将正负号单独处理
    为避免计算过程出现溢出，采用long
    溢出条件有两个：1.divisor == 0  2. dividend == INT_MIN && divisor == -1
30.substring-with-concatenation-of-all-words 给一个字符串，和一堆等长度的单词,在字符串中找出所有单词组成的字串的位置。
  利用map存储words里每个word应该出现的次数，然后对可能的起始位置遍历，利用map2存储从该位置出发，
  实际上每个word出现的次数；如果得到的word不在map里或者word出现的次数过多，说明此位置不满足条件
31.next-permutation 给定一个整数序列，返回该序列的下一个字典序列；如果是降序序列，直接返回升序序列
  对所给序列，从右至左查找，找到第一个index，使得nums[index]<nums[index+1]，如果找不到，说明原序列为降序排序，直接返回升序序列；
  对找到的index,从nums.size()-1遍历到index+1,找到第一个大于nums[index]的i，交换nums[index],nums[i]；
  最后再将nums[index+1..nums.size()-1]逆序即可
32.longest-valid-parentheness 给定一个由'('和')'组成的字符串，返回这个字符串最长合法括号的长度
  声明栈stack<int> st，用于存储所有未匹配的下标，然后利用st求出最长匹配长度
33.search-in-rotated-sorted-array 给定一个数组，它是升序数组在某个位置旋转所得，即012345在3旋转得到345012...返回给定target在数组里的下标
  初始化low=0,high=nums.size()-1,mid=(low+high)/2，如果nums[mid]=target则命中返回；否则mid的左右序列必定有一个是有序的；
  如果nums[mid]<=nums[high]，说明从mid..high是有序的，此时如果target位于mid-high，则low=mid+1,否则high=mid-1;
  如果nums[mid]>=nums[low],说明从low..mid是有序的，此时如果target位于low-mid，则high=mid-1,否则low=mid+1。
  即[l..m]和[m..r]中必有一个有序，按情况更新l或r即可
34.search for a range 给定一个升序数组和target，返回target在数组内的起始和结束位置。要求时间复杂度为O(logn)
  二分法，命中后，通过两个下标分别向前向后扫描数组，返回起始和结束下标
35.search insert position 给定一个升序数组和target，如果在数组内找到target则返回下标，如果没找到则返回target应插入的位置。假设数组内无重复元素
  对于有序数组的位置查找，依然采用二分法解决。
36.valid-sudoku 判断所给的9*9数独表是否合法，空格用'.'代表，空格不需要判断
  分别遍历每行，每列，每个子表，如果都合法则返回true
37.Sudoku Solver 给定一个不完整的数独表，完成数独表填写。假设唯一解
  dfs
  声明函数util(vector<vector<char>>, int pos)，对于位置0..80遍历判断，如果pos>=81说明前81个位置均已放入相应数字，直接返回true
  否则，先得到pos对应的行下标i和列下标j，对于board[i][j]判断，如果不是'.'，直接判断下一位置；
  否则，对于可能放入的9个字符遍历，如果字符c不在i行且不在j列且不在i,j确定的子表内，则将c放入board[i][j]，然后进行下一位置判断；
  注意回溯之后要恢复board。
38.count and say 数和说数列如下：1,11,21,1211,111221..给定一个整数n，生成第n个这样的序列
  循环求解每次所得字符串即可
39.combination-sum 给定一个无重复元素的set集合，和一个int类型的target，求出所有利用set里的元素能构成target的结果。set里的元素可多次使用，结果不能有重复
  先将set排序，然后利用dfs求解
40.combination-sumII 与上一题类似，给定一个集合和目标target，集合里的每个元素只能使用一次，返回所有的结果集合
  与上一题类似，排序+dfs
  tips：本题存在几个需要注意的地方
  1.每个元素只能使用一次，所以回溯时的下标变成i+1
  2.在去重之后，应该有一个判定是否为candidates结尾的判断，否则发生数组越界。神奇的是，本题的所有case在不判断的情况下都能通过，但还是应该注意
41.first missing positive 给定一个无序的数组，找出数组中缺失的第一个正整数。要求算法复杂度为O(n)，使用常数内存空间
  遍历一次数组，对于下标i：如果nums[i]是合法的，将它放到正确的位置上，注意应该使用循环，对换到位置i的元素不断处理。即if(nums[i]==5),将它与nums[4]交换
  然后遍历数组，找到第一个位置上错误的下标i,返回i+1
42.trapping rain water 给定一个非负正数序列，分别表示高度，求出以这些高度为边界所能存储的水量
  1.为了确定每次能够存储的水量，需要维护leftwall,rightwall，分别表示左边墙和右边墙高度
  2.当height[left]<=height[right]时：
    说明此时height[left]一定不大于右边墙，因此将它与左边墙比较，如果height>=heightwall，则更新左边墙高度，否则存水；往右走一格
  3.右边同理，处理完往左走一格
43.multiply strings 非负大整数乘法
  按位计算，迭代。
  1.对于大整数乘法，结果最多可以有num1.size()+num2.size()位
  2.对于num1[i]和num2[j]，他们共同决定结果的res[i+j+1]
  3.对于给定的i，当与所有num2[j]计算结束后，最后一个进位应加入res[i]。可以这样理解，对所有j遍历结束时，j=0，此时共同决定res[i+1]，因此退出循环时最后进位加入res[i]
  4.最后别忘记对res取子串，因为可能结果位数小于num1.size()+num2.size()
44.wildcard matching 通配符匹配，'?'代表单个字符，'*'代表任意字符串，包括空串
  f[i][j]: s[0..i-1]与p[0..j-1]是否匹配，问题转化为求解f[m][n]
  f[i][j]: 
    if(p[j-1] != '*'): 判断s与j的末位是否匹配，去除s与p的末位
    if(p[j-1] == '*'): 
      *可能表示empty，此时仅去除p的末位，f[i][j-1]
      *可能表示>=1个任意字符，此时仅去除s的末位，f[i-1][j]
  初始化：
    1.f[0][0]=true;
    2.p为空时，对于s的第i个字符，都有f[i][0]=false;
    3.s为空时，对于p的第j个字符，判断：p的末位即p[j-1]=='*' && f[0][j-1]
45.jump game II 给定一个非负整数序列，nums[i]表示在i位置能跳跃的最大步数，求出从i=0跳跃到i=nums.size()-1所需的最小步数(假设一定能到达最后)
  贪心算法，对nums遍历，如果i超过了上一跳能到达的最远位置，则跳数+1，并更新上一跳的最远位置为本跳最远位置。如果本跳最远位置超过了序列尾则返回当前跳数
      last-上一跳能到达的最远位置 
      curr-当前跳能到达的最远位置 
      jump-跳数
46.permutation 给定一个无重复数字的set，返回所有可能的字典序列
  dfs,利用vector<bool> used存储该位是否已使用
47.Permutations II 给定可能包含重复值的序列，求出所有可能的字典序
  与上一题几乎一样，多了重复元素的判断，为了判断重复元素，这里加入对nums的排序，使重复元素近邻
48.rotate image 实现n*n矩阵顺时针旋转90度
  对于每个需要旋转的元素，将其放到对应位置 a[i][j]->a[j][n-i-1]->a[n-i-1][n-j-1]->a[n-j-1][i]->a[i][j]
  1. 四个一组，找对应关系
  2. 注意下标控制
49.group anagrams 给定字符串数组，返回所有包含相同字符的字符串
  声明一个key为string，value为vector<string>的map，其中注意对key进行排序
50.Pow(x, n)
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0, cur = x;
        
        if(n == 0) return res;
        if(n < 0){
            if(n == INT_MIN) return 1.0 / (myPow(x, INT_MAX) * x);
            else return 1.0 / myPow(x, -n);
        }
        while(n > 0){
            if(n & 0x1) res *= cur;
            cur *= cur;
            n = n >> 1;
        }
        return res;
    }
};
51.N-Queens
52.N-QueensII
  经典问题，dfs。按行进行递归(避免行冲突)，对该行的每个位置，判断是否可以放入皇后，只需进行列/45°/135°三个方向的判定即可
53.Maximum Subarray 给定一个数组，返回数组中子串最大和
  利用currMax存储以nums[i]结尾的最大子串和，如果currMax>max则更新max
54.Spiral Matrix 将给定矩阵螺旋输出
  分别按向右，向下，向左，向上四个方向扫描并存储
55.Jump Game 对给定数组，从位置0出发，判断能否走到最后
  与45题比较。本题更简单，利用curr存储当前跳最远距离。如果最远位置等于下标，说明无法再往前跳，返回false；如果最远位置>=nums.size()-1，说明可以到达
56.Merge Intervals 给定一些时间间隔Interval，合并有重合的Interval
  先按照Interval.start进行升序排序，声明tmp，初始化为intervals[0]，然后遍历剩余元素，进行相应操作。
  注意sort(a.begin(), a.end(), comp)的写法
57.insert intervals 将newInterval插入intervals序列，假设原intervals序列按照Interval.start升序排列
  与上一题基本一致，先将newInterval插入intervals，然后调用上一题代码即可
58.length of last word 求最后一个word的长度
  从右至左遍历，找到第一个非空字符串，返回其长度即可
59.Spiral Matrix II 与54题几乎一致，改读取为填入。给定行数列数n，按照螺旋式填写矩阵
  与54题一致，定义startRow,endRow,startCol,endCol,然后逐个填入num
60.Permutation Sequence 对于给定n，有n!个字典序列，返回第k个序列
  对于[1..n]有n!个n位字典序列，n! = n*(n-1)!。即把n!个字典序列分成n份，每份是剩余n-1个字符组成的(n-1)!个字典序列。
  根据k求出每一位应该填入的字符，循环求出n位字典序列。
61.Rotate List 将链表右移k个位置
  这里的k是可以大于链表长度的，因此先求出链表长度num，然后pos = k % num表示右移的量。
  链表右移：
    声明两个指针pre,cur均指向头节点，先把pre右移pos个位置，然后当pre->next != NULL时，同时右移pre和cur，此时pre指向尾节点，cur->next为
    结果的头节点。
62.Unique Paths 从矩阵左上角走到右下角共有多少条路径
  动态规划。
  res[i][j]：从[0][0]走到[i][j]的路径数，则题目变成求解res[m-1][n-1]
  res[i][j] = res[i-1][j] + res[i][j-1];
  初始化：start位置，第一行，第一列
63.Unique Paths II 与上一题目相似，当obstacleGrid[i][j]=1时表示为障碍物
  用动归解决，当前点若为障碍点，则当前点的方案数为0，否则，到当前点的方案数为它的上边格子和左边格子的方案和
64.Minimum Path Sum 给定一个矩阵，矩阵元素非负，求出从左上走到右下的最小数之和
  解题思路：简单的动归。
  dp[i][j]:从dp[0][0]到dp[i][j]的最小数之和，题目变成求解dp[m-1][n-1]
  dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
  初始化：出发点，第一行，第一列
65.Valid Number 判断给定字符串是否是数字
  1.去除s前后的空格，如果s为空，说明原s全部由空格组成，返回false
  2.合法数字可以由'+','-'号开头，但正负号后必须有内容
  3.正负号之后可以跟数字或小数点，但小数点个数不能大于一，数字个数不能为0
  4.如果有指数符号'e'/'E'，同理指数符号后必须有内容
  5.指数符号后可以跟正负号或数字且正负号不能在最后
  6.最终返回index == s.size();即合法数字后不能再有其他不合法符号
  综上：小数点一个，指数符号一个，正负号两个
66.Plus One 一个非负整数由数组表示，数组下标0的位置保存该数最高位，返回该数加1的数
  从后往前遍历数组，对末位执行加1操作，利用flag保存进位
67.Add Binary 二进制加法
  假设a的长度总是不小于b的长度，若b长度为0，直接返回a；否则的话，对于a,b从右向左扫描，当a,b均不为空时，当只有a不为空时
68.Text Justification 给定一个字符串数组和每行长度maxWidth，贪心地把每个字符串放入当前行，每个字符串之间用空格分开，空格平均分布，且当空格不能平均分布时，多余空格
从左往右填入；最后一行，每个字符串之间只放入一个空格，剩下的空格全部填入最后
  对字符串数组遍历，首先计算得到所有能放在当前行的字符串words[i]..words[i+k-1]
  然后对于最后一行，每个字符串之间填入一个空格；对于其他行，按要求填入空格
69.Sqrt(x) 二分法
  int mySqrt(int x) {
        if(x < 2) return x;
        
        int low = 0, high = x;
        while(low <= high){
            int mid = (low + high) / 2;
            int div = x / mid;
            if(div == mid) return mid;
            else if(div < mid) high = mid - 1;
            else low = mid + 1;
        }
        return high;
    }
70.Climbing Stairs 爬梯子，一共需要爬n步，每步可以爬1或2格，求共有多少种爬法
  解题思路：简单的dp
  dp[i]：从0爬到i的不同路径数，问题转化为求解dp[n]
  dp[i] = dp[i-1] + dp[i-2];
  初始化：dp[0] = 1, dp[1] = 1
71.Simplify Path  简化所给的Unix形式的绝对路径
  解题思路：利用stack。
  保存每两个'/'之间的字符串，如果是".."则弹出用栈保存的上一层文件夹，如果是'.'或空则不做处理，如果是字符串则将当前文件夹名压入栈。
  如果栈空则压入'/'，最后利用栈得到结果
72.Edit Distance 给定字符串word1，word2，求从word1变成word2所需的最小步数。每步有三种情况：replace, delete, insert
  解题思路：dp
  dp[i][j]：将word1[0..i-1]变成word2[0..j-1]所需的最小步数，则问题转化为求解dp[m][n]，其中m，n分别为word1和word2的长度
  dp[i][j]：如果word1[i-1]=word2[j-1]，则dp[i][j] = dp[i-1][j-1]
            否则，有三种转换方法:
              replace: dp[i][j] = dp[i-1][j-1] + 1;
              delete:  dp[i][j] = dp[i-1][j] + 1; 即删除word1[i-1]，然后加上word1[0..i-2]变成word2[0..j-1]的步数
              insert:  dp[i][j] = dp[i][j-1] + 1; 即将word1[0..j-1]变成word2[0..j-2]，然后在word1最后填入word2[j-1]
  初始化：对应word1/word2为空的情况，易知分别需要i/j个delete/insert操作
73.Set Matrix Zeroes 对给定矩阵，如果matrix[i][j]为0，则把矩阵的该行和该列全部置0
  解题思路：把每行是否应置0存入该行第一列的元素中，把每列是否应置0存入该列第一行的元素中，这样，对于第一行和第一列都应存入matrix[0][0]，
  所以额外声明flag1,flag2分别存储第一行和第一列是否应置0。然后对除去第一行第一列的矩阵执行置零操作，最后根据标志位对第一行第一列分别置零。
74.Search a 2D Matrix 在有序二维数组里查找target
  解题思路：将二维数组看作一维数组，二分法查找即可
75.Sort Colors 颜色排序，红白蓝分别由012代替，对于给定数组排序
  解题思路：1.快排 2.归并排序 3.声明low,mid,high，low是0的右边界，high是2的左边界，mid用于遍历数组。遇到0，则交换nums[low]和nums[mid]，
  并且low++,mid++，保证mid永远不小于low； 遇到1，则mid++继续扫描；遇到2，则交换nums[mid]和nums[high]，并且high--
         遇到1，则mid++继续扫描；遇到2，则交换nums[mid]和nums[high]，并且high--
